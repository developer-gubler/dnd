spring.application.name=api-creature-reader
spring.main.allow-bean-definition-overriding=true
#spring.jpa.defer-datasource-initialization=true
#spring.jpa.hibernate.ddl-auto=create-drop
#spring.sql.init.mode=never

### PostgreSQL ###
# NOTE: R2DBC does NOT support relations  (ie foreign key definitions).
# 		 As a result, I had to change spring.datasource.* to spring.r2dbc.*
# 		 It is important to create your tables outside of JPA so that
# 		 the tables are created with the foreign key and the database (instead
# 		 of the application) can still enforce the relation.
# NOTE: For some reason, the following values will not work if I try to pass
#		them in via compose.yaml. Nor does it work when I specify the url
#		as dnd_database (ie Docker container name) instead of 172.18.0.2.
spring.r2dbc.url=r2dbc:postgresql://172.18.0.2:5432/dnd-database
#spring.datasource.driver-class-name=org.postgresql.Driver
spring.r2dbc.username=dnd-user
spring.r2dbc.password=dnd-secret
###spring.jpa.database-platform=org.hibernate.dialect.H2Dialect

# NOTE: https://docs.spring.io/spring-boot/how-to/data-initialization.html
# NOTE: There are two ways to initialize the database: 1) Hibernate or 2) basic SQL scripts.  It is recommended to only use one of these, not both.
# NOTE: Disable Hibernate initialization.
# NOTE: spring.jpa.hibernate.ddl-auto defaults to "create-drop" when embedded and no schema manager (ie Flyway or Liquibase). "none" otherwise. we set it to "none" because we don't want Hibernate to do the initialization
spring.jpa.hibernate.ddl-auto=none

# NOTE: We leave this as the default of false because we don't want the Hibernate automatic schema generation based on the Entity classes (ie we are doing database initialization via basic SQL scripts -- schema.sql and data.sql)
###spring.jpa.defer-datasource-initialization=true

# NOTE: Enable database initialization using basic SQL scripts
# NOTE: We are specifying spring.sql.init.platform because we want database specific scripts
# NOTE: We are specifying spring.sql.init.mode=always because we want to use SQL script initialization
# NOTE: We are specifying spring.sql.init.continue-on-error=true because the standard behavior is to fail-fast (ie stop processing when there is an error). We know that there will be an error with the script on every run after the first on the "CREATE TYPE <type>" commands because PostgreSQL does not have a "CREATE TYPE IF NOT EXISTS <type>" command.
spring.sql.init.platform=postgresql
spring.sql.init.mode=never
spring.sql.init.continue-on-error=true
###spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true
